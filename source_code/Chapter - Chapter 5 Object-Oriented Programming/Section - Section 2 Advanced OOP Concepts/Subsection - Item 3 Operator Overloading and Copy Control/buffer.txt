#include <algorithm>
#include <cstddef>
#include <cstring>
#include <iostream>
#include <memory>
#include <utility>
#include <compare>

class Buffer {
public:
    Buffer() noexcept = default;

    explicit Buffer(std::size_t n)
        : size_(n), data_(n ? std::make_unique<unsigned char[]>(n) : nullptr)
    {
        std::fill_n(data_.get(), size_, 0);
    }

    Buffer(const Buffer& other)
        : size_(other.size_), data_(other.size_ ? std::make_unique<unsigned char[]>(other.size_) : nullptr)
    {
        if (size_) std::memcpy(data_.get(), other.data_.get(), size_);
    }

    Buffer(Buffer&&) noexcept = default;
    Buffer& operator=(Buffer&&) noexcept = default;

    Buffer& operator=(const Buffer& other) {
        if (this != &other) {
            Buffer tmp(other);
            swap(tmp);
        }
        return *this;
    }

    unsigned char& operator[](std::size_t i) noexcept { return data_[i]; }
    unsigned char  operator[](std::size_t i) const noexcept { return data_[i]; }

    [[nodiscard]] std::size_t size() const noexcept { return size_; }

    friend void swap(Buffer& lhs, Buffer& rhs) noexcept {
        using std::swap;
        swap(lhs.size_, rhs.size_);
        swap(lhs.data_, rhs.data_);
    }

    friend std::strong_ordering operator<=>(const Buffer& a, const Buffer& b) noexcept {
        if (auto cmp = a.size_ <=> b.size_; cmp != 0) return cmp;
        if (a.size_ == 0) return std::strong_ordering::equal;
        const int r = std::memcmp(a.data_.get(), b.data_.get(), a.size_);
        return r <=> 0;
    }

    friend bool operator==(const Buffer& a, const Buffer& b) noexcept = default;

private:
    std::size_t size_ = 0;
    std::unique_ptr<unsigned char[]> data_;
};

int main() {
    Buffer a(8);
    Buffer b = a;
    Buffer c = std::move(a);
    c[0] = 42;
    std::cout << std::boolalpha << (b == c) << '\n';
    std::cout << (b < c ? "b < c" : "b >= c") << '\n';
}