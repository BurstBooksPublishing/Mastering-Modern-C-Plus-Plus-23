#include <type_traits>
#include <utility>

// A reusable, stateless addition functor with SFINAE-constrained call operator.
struct Add {
    template<typename T, typename U>
    constexpr auto operator()(T&& lhs, U&& rhs) const
        noexcept(noexcept(std::declval<T>() + std::declval<U>()))
        -> std::enable_if_t<std::is_arithmetic_v<std::decay_t<T>> &&
                            std::is_arithmetic_v<std::decay_t<U>>,
                            decltype(std::declval<T>() + std::declval<U>())> {
        return std::forward<T>(lhs) + std::forward<U>(rhs);
    }
};

// Usage example (commented out to keep the snippet minimal)
// constexpr Add add;
// static_assert(add(3, 4) == 7);