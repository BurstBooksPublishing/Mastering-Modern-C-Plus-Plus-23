#include <memory>
#include <mutex>
#include <condition_variable>

template<typename T>
class Watch {
public:
    explicit Watch(std::shared_ptr<T> ptr) : ptr_(std::move(ptr)) {}

    // Atomically replace the watched pointer
    void reset(std::shared_ptr<T> newPtr) {
        {
            std::lock_guard<std::mutex> lock(mtx_);
            ptr_ = std::move(newPtr);
        }
        cv_.notify_all();
    }

    // Wait until the pointer changes
    void wait() {
        std::unique_lock<std::mutex> lock(mtx_);
        auto old = ptr_;
        cv_.wait(lock, [&] { return ptr_ != old; });
    }

    // Get current pointer (thread-safe)
    std::shared_ptr<T> get() const {
        std::lock_guard<std::mutex> lock(mtx_);
        return ptr_;
    }

private:
    std::shared_ptr<T> ptr_;
    mutable std::mutex mtx_;
    std::condition_variable cv_;
};