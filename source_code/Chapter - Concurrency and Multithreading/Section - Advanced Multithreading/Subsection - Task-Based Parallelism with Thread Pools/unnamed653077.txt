#include <algorithm>
#include <future>
#include <iostream>
#include <numeric>
#include <vector>

int main() {
    constexpr std::size_t kSize = 1'000'000;
    std::vector<int> data(kSize);
    std::iota(data.begin(), data.end(), 1);

    const unsigned hw = std::thread::hardware_concurrency();
    const unsigned threads = hw ? hw : 4;
    const std::size_t chunk = (data.size() + threads - 1) / threads;

    std::vector<std::future<long long>> futures;
    futures.reserve(threads);

    for (std::size_t i = 0; i < data.size(); i += chunk) {
        auto first = data.begin() + i;
        auto last  = std::min(first + chunk, data.end());
        futures.emplace_back(std::async(std::launch::async,
            [first, last] {
                return std::accumulate(first, last, 0LL,
                                       [](long long acc, int v) { return acc + 1LL * v * v; });
            }));
    }

    long long total = 0;
    for (auto& f : futures) total += f.get();

    std::cout << "Total sum of squares: " << total << '\n';
    return 0;
}