#include <atomic>
#include <chrono>
#include <cstddef>
#include <cstdint>
#include <iostream>
#include <memory>
#include <optional>
#include <thread>
#include <vector>

template <typename T>
class SpscRingBuffer {
public:
    explicit SpscRingBuffer(std::size_t capacity_power_of_two)
        : capacity_(capacity_power_of_two),
          mask_(capacity_power_of_two - 1),
          buffer_(capacity_power_of_two) {
        if ((capacity_power_of_two & mask_) != 0 || capacity_power_of_two == 0)
            throw std::invalid_argument("capacity must be a non-zero power of two");
        head_.store(0, std::memory_order_relaxed);
        tail_.store(0, std::memory_order_relaxed);
    }

    bool try_push(const T& value) {
        const std::size_t head = head_.load(std::memory_order_relaxed);
        const std::size_t tail = tail_.load(std::memory_order_acquire);
        if (head - tail >= capacity_) return false;
        buffer_[head & mask_] = value;
        head_.store(head + 1, std::memory_order_release);
        return true;
    }

    bool try_push(T&& value) {
        const std::size_t head = head_.load(std::memory_order_relaxed);
        const std::size_t tail = tail_.load(std::memory_order_acquire);
        if (head - tail >= capacity_) return false;
        buffer_[head & mask_] = std::move(value);
        head_.store(head + 1, std::memory_order_release);
        return true;
    }

    std::optional<T> try_pop() {
        const std::size_t tail = tail_.load(std::memory_order_relaxed);
        const std::size_t head = head_.load(std::memory_order_acquire);
        if (head == tail) return std::nullopt;
        T value = std::move(buffer_[tail & mask_]);
        tail_.store(tail + 1, std::memory_order_release);
        return value;
    }

private:
    const std::size_t capacity_;
    const std::size_t mask_;
    std::vector<T> buffer_;
    alignas(64) std::atomic<std::size_t> head_;
    alignas(64) std::atomic<std::size_t> tail_;
};

int main() {
    constexpr std::size_t N = 1 << 16;
    SpscRingBuffer<std::uint64_t> q(N);

    constexpr std::uint64_t ITEMS = 5'000'000;
    std::atomic<bool> producer_done{false};

    const auto t0 = std::chrono::steady_clock::now();

    std::thread producer([&]() {
        for (std::uint64_t i = 0; i < ITEMS; ++i) {
            while (!q.try_push(i)) std::this_thread::yield();
        }
        producer_done.store(true, std::memory_order_release);
    });

    std::thread consumer([&]() {
        std::uint64_t expected = 0;
        while (expected < ITEMS) {
            if (auto opt = q.try_pop()) {
                if (*opt != expected) {
                    std::cerr << "out-of-order: got " << *opt << " expected " << expected << '\n';
                    std::terminate();
                }
                ++expected;
            } else {
                std::this_thread::yield();
            }
        }
    });

    producer.join();
    consumer.join();

    const auto t1 = std::chrono::steady_clock::now();
    const auto ms = std::chrono::duration_cast<std::chrono::milliseconds>(t1 - t0).count();
    std::cout << "Processed " << ITEMS << " items in " << ms << " ms\n";
    return 0;
}