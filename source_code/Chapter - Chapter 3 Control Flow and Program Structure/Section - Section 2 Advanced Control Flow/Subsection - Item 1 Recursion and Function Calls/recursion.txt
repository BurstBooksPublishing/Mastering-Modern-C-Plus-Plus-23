#include <cstdint>
#include <iostream>
#include <unordered_map>

// Returns n! using 64-bit arithmetic; overflows for n > 20.
constexpr std::uint64_t factorial(unsigned n) noexcept {
    std::uint64_t acc = 1;
    for (unsigned i = 2; i <= n; ++i) acc *= i;
    return acc;
}

// Generic fixed-point combinator for recursive lambdas.
template <typename F>
struct fix_point {
    F f;
    template <typename... Args>
    decltype(auto) operator()(Args&&... args) const {
        return f(*this, std::forward<Args>(args)...);
    }
};
template <typename F> fix_point(F) -> fix_point<F>;

// Memoized Fibonacci: cache must be pre-seeded with {0,0} and {1,1}.
std::uint64_t fib_memo(unsigned n, std::unordered_map<unsigned, std::uint64_t>& cache) {
    auto [it, inserted] = cache.try_emplace(n);
    if (!inserted) return it->second;
    return it->second = fib_memo(n - 1, cache) + fib_memo(n - 2, cache);
}

int main() {
    std::cout << "factorial(10): " << factorial(10) << '\n';

    auto fib = fix_point([](auto&& self, unsigned n) -> std::uint64_t {
        return (n < 2) ? n : self(n - 1) + self(n - 2);
    });
    std::cout << "fib_lambda(20): " << fib(20) << '\n';

    std::unordered_map<unsigned, std::uint64_t> cache{{0, 0}, {1, 1}};
    std::cout << "fib_memo(50): " << fib_memo(50, cache) << '\n';
}