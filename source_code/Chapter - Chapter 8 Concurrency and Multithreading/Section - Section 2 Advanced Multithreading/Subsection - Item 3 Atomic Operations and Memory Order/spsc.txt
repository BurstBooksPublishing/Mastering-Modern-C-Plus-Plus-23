#include <atomic>
#include <cstddef>
#include <memory>
#include <optional>
#include <stdexcept>
#include <vector>

template <typename T>
class SpscQueue {
public:
    explicit SpscQueue(std::size_t capacity_pow2)
        : size_(capacity_pow2),
          mask_(capacity_pow2 - 1),
          buffer_(capacity_pow2) {
        if (capacity_pow2 == 0 || (capacity_pow2 & (capacity_pow2 - 1)) != 0)
            throw std::invalid_argument("capacity must be a power of two");
        head_.store(0, std::memory_order_relaxed);
        tail_.store(0, std::memory_order_relaxed);
    }

    bool push(const T& value) {
        return emplaceInternal(value);
    }

    bool push(T&& value) {
        return emplaceInternal(std::move(value));
    }

    template <typename... Args>
    bool emplace(Args&&... args) {
        return emplaceInternal(std::forward<Args>(args)...);
    }

    std::optional<T> pop() {
        std::size_t head = head_.load(std::memory_order_relaxed);
        std::size_t tail = tail_.load(std::memory_order_acquire);
        if (head == tail) return std::nullopt;

        T value = std::move(buffer_[head]);
        head_.store((head + 1) & mask_, std::memory_order_release);
        return value;
    }

    std::size_t capacity() const noexcept { return size_; }

private:
    template <typename U>
    bool emplaceInternal(U&& value) {
        std::size_t tail = tail_.load(std::memory_order_relaxed);
        std::size_t next = (tail + 1) & mask_;
        if (next == head_.load(std::memory_order_acquire)) return false;

        buffer_[tail] = std::forward<U>(value);
        tail_.store(next, std::memory_order_release);
        return true;
    }

    const std::size_t size_;
    const std::size_t mask_;
    std::vector<T> buffer_;
    alignas(64) std::atomic<std::size_t> head_{0};
    alignas(64) std::atomic<std::size_t> tail_{0};
};