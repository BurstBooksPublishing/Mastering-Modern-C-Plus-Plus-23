#include <condition_variable>
#include <deque>
#include <functional>
#include <future>
#include <iostream>
#include <mutex>
#include <stdexcept>
#include <stop_token>
#include <thread>
#include <vector>

class ThreadPool {
public:
    explicit ThreadPool(std::size_t n = std::thread::hardware_concurrency(),
                        std::size_t max_q = 1024)
        : max_queue_size(max_q) {
        if (n == 0) throw std::invalid_argument("ThreadPool: n must be > 0");
        for (std::size_t i = 0; i < n; ++i) {
            workers.emplace_back([this](std::stop_token st) { worker_loop(st); });
        }
    }

    template <typename F, typename... Args>
    auto enqueue(F&& f, Args&&... args) -> std::future<decltype(f(args...))> {
        using Ret = decltype(f(args...));
        using PackagedTask = std::packaged_task<Ret()>;

        auto task = std::make_shared<PackagedTask>(
            std::bind(std::forward<F>(f), std::forward<Args>(args)...));
        std::future<Ret> fut = task->get_future();

        {
            std::unique_lock lock(mtx);
            not_full.wait(lock, [this] { return stopped || tasks.size() < max_queue_size; });
            if (stopped) throw std::runtime_error("ThreadPool stopped");
            tasks.emplace_back([task = std::move(task)] { (*task)(); });
        }
        not_empty.notify_one();
        return fut;
    }

    void shutdown() {
        {
            std::scoped_lock lock(mtx);
            stopped = true;
        }
        for (auto& t : workers) t.request_stop();
        not_empty.notify_all();
        not_full.notify_all();
    }

    ~ThreadPool() { shutdown(); }

private:
    void worker_loop(std::stop_token st) {
        while (true) {
            std::function<void()> task;
            {
                std::unique_lock lock(mtx);
                not_empty.wait(lock, [this, &st] {
                    return stopped || !tasks.empty() || st.stop_requested();
                });
                if ((st.stop_requested() || stopped) && tasks.empty()) return;
                task = std::move(tasks.front());
                tasks.pop_front();
            }
            not_full.notify_one();
            try { task(); } catch (...) { std::cerr << "Task threw an exception\n"; }
            if (st.stop_requested()) return;
        }
    }

    std::vector<std::jthread> workers;
    std::deque<std::function<void()>> tasks;
    std::mutex mtx;
    std::condition_variable not_empty;
    std::condition_variable not_full;
    std::size_t max_queue_size;
    bool stopped{false};
};