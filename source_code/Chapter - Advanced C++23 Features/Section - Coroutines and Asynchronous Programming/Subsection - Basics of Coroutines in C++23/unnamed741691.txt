#include <coroutine>
#include <iostream>
#include <memory>
#include <stdexcept>

class Generator {
public:
    struct promise_type {
        int current_value{};

        Generator get_return_object() noexcept {
            return Generator{std::coroutine_handle<promise_type>::from_promise(*this)};
        }
        std::suspend_always initial_suspend() noexcept { return {}; }
        std::suspend_always final_suspend() noexcept { return {}; }
        void unhandled_exception() { throw; }
        std::suspend_always yield_value(int value) noexcept {
            current_value = value;
            return {};
        }
        void return_void() noexcept {}
    };

    using handle_type = std::coroutine_handle<promise_type>;

    explicit Generator(handle_type h) noexcept : handle_(h) {}
    ~Generator() { if (handle_) handle_.destroy(); }

    Generator(const Generator&) = delete;
    Generator& operator=(const Generator&) = delete;
    Generator(Generator&& other) noexcept : handle_(std::exchange(other.handle_, {})) {}
    Generator& operator=(Generator&& other) noexcept {
        if (this != &other) {
            if (handle_) handle_.destroy();
            handle_ = std::exchange(other.handle_, {});
        }
        return *this;
    }

    bool next() {
        if (!handle_.done()) {
            handle_.resume();
        }
        return !handle_.done();
    }

    int value() const { return handle_.promise().current_value; }

private:
    handle_type handle_;
};

Generator sequence(int start, int end) {
    for (int i = start; i <= end; ++i) {
        co_yield i;
    }
}

int main() {
    Generator gen = sequence(1, 5);
    while (gen.next()) {
        std::cout << gen.value() << ' ';
    }
    std::cout << '\n';
}