#include <algorithm>
#include <iostream>
#include <iterator>
#include <memory>
#include <numeric>

template <typename T>
class CustomContainer {
public:
    using value_type      = T;
    using pointer         = T*;
    using const_pointer   = const T*;
    using reference       = T&;
    using const_reference = const T&;
    using size_type       = std::size_t;
    using difference_type = std::ptrdiff_t;

    class Iterator {
    public:
        using iterator_category = std::random_access_iterator_tag;
        using value_type        = T;
        using difference_type   = std::ptrdiff_t;
        using pointer           = T*;
        using reference         = T&;

        Iterator() noexcept : ptr_(nullptr) {}
        explicit Iterator(pointer ptr) noexcept : ptr_(ptr) {}

        reference operator*()  const noexcept { return *ptr_; }
        pointer   operator->() const noexcept { return  ptr_; }

        Iterator& operator++()    noexcept { ++ptr_; return *this; }
        Iterator  operator++(int) noexcept { Iterator tmp(*this); ++ptr_; return tmp; }
        Iterator& operator--()    noexcept { --ptr_; return *this; }
        Iterator  operator--(int) noexcept { Iterator tmp(*this); --ptr_; return tmp; }

        Iterator  operator+(difference_type n) const noexcept { return Iterator(ptr_ + n); }
        Iterator  operator-(difference_type n) const noexcept { return Iterator(ptr_ - n); }
        difference_type operator-(const Iterator& rhs) const noexcept { return ptr_ - rhs.ptr_; }

        Iterator& operator+=(difference_type n) noexcept { ptr_ += n; return *this; }
        Iterator& operator-=(difference_type n) noexcept { ptr_ -= n; return *this; }

        reference operator[](difference_type n) const noexcept { return *(ptr_ + n); }

        bool operator==(const Iterator& rhs) const noexcept { return ptr_ == rhs.ptr_; }
        bool operator!=(const Iterator& rhs) const noexcept { return ptr_ != rhs.ptr_; }
        bool operator< (const Iterator& rhs) const noexcept { return ptr_ <  rhs.ptr_; }
        bool operator<=(const Iterator& rhs) const noexcept { return ptr_ <= rhs.ptr_; }
        bool operator> (const Iterator& rhs) const noexcept { return ptr_ >  rhs.ptr_; }
        bool operator>=(const Iterator& rhs) const noexcept { return ptr_ >= rhs.ptr_; }

    private:
        pointer ptr_;
    };

    using iterator       = Iterator;
    using const_iterator = Iterator; // Simplified; could be a separate const iterator

    explicit CustomContainer(size_type size)
        : size_(size), data_(std::make_unique<T[]>(size_)) {}

    iterator       begin() noexcept { return iterator(data_.get()); }
    iterator       end()   noexcept { return iterator(data_.get() + size_); }
    const_iterator begin() const noexcept { return const_iterator(data_.get()); }
    const_iterator end()   const noexcept { return const_iterator(data_.get() + size_); }

    size_type size() const noexcept { return size_; }

private:
    size_type                size_;
    std::unique_ptr<T[]>     data_;
};

int main() {
    CustomContainer<int> container(5);
    std::iota(container.begin(), container.end(), 1);

    std::copy(container.begin(), container.end(),
              std::ostream_iterator<int>(std::cout, " "));
    std::cout << '\n';
}