#include <atomic>
#include <chrono>
#include <iostream>
#include <latch>
#include <stdexcept>
#include <string>
#include <thread>
#include <vector>

int main(int argc, char* argv[]) {
    try {
        const int threads = (argc > 1) ? std::stoi(argv[1]) : 8;
        const int iterations = (argc > 2) ? std::stoi(argv[2]) : 1'000'000;
        const std::string mode = (argc > 3) ? argv[3] : "race";

        if (threads <= 0 || iterations <= 0) throw std::invalid_argument("threads and iterations must be positive");

        int non_atomic_counter = 0;
        std::atomic<int> atomic_counter{0};

        std::latch start_latch(threads);
        std::vector<std::thread> th;
        th.reserve(threads);

        auto worker = [&](int id) {
            start_latch.arrive_and_wait();
            for (int i = 0; i < iterations; ++i) {
                if (mode == "race") {
                    non_atomic_counter += 1; // data race
                } else {
                    atomic_counter.fetch_add(1, std::memory_order_relaxed);
                }
            }
        };

        const auto t0 = std::chrono::steady_clock::now();
        for (int i = 0; i < threads; ++i) th.emplace_back(worker, i);
        for (auto& t : th) t.join();
        const auto t1 = std::chrono::steady_clock::now();

        const auto elapsed_ms = std::chrono::duration_cast<std::chrono::milliseconds>(t1 - t0).count();
        std::cout << "mode=" << mode
                  << " final=" << (mode == "race" ? non_atomic_counter : atomic_counter.load())
                  << " elapsed_ms=" << elapsed_ms
                  << " threads=" << threads << '\n';
    } catch (const std::exception& ex) {
        std::cerr << "Error: " << ex.what() << '\n';
        return 1;
    }
    return 0;
}