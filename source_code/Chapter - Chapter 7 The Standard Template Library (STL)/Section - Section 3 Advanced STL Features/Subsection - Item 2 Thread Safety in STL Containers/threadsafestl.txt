#include <atomic>
#include <iostream>
#include <map>
#include <mutex>
#include <random>
#include <shared_mutex>
#include <thread>
#include <vector>

int main() {
    constexpr std::size_t N = 1'000;
    std::vector<int> counters(N, 0);
    std::map<int, int> index_map;
    std::shared_mutex map_mtx;

    auto worker = [&](int tid, int iterations) {
        std::mt19937_64 rng(tid);
        std::uniform_int_distribution<std::size_t> dist(0, N - 1);
        for (int i = 0; i < iterations; ++i) {
            std::size_t idx = dist(rng);
            std::atomic_ref<int> ref(counters[idx]);
            ref.fetch_add(1, std::memory_order_relaxed);
        }
    };

    auto map_reader = [&](int key) {
        std::shared_lock lock(map_mtx);
        if (auto it = index_map.find(key); it != index_map.end())
            std::cout << "map[" << key << "]=" << it->second << '\n';
    };

    auto map_writer = [&](int key, int value) {
        std::unique_lock lock(map_mtx);
        index_map[key] = value;
    };

    std::vector<std::thread> threads;
    for (int t = 0; t < 8; ++t) threads.emplace_back(worker, t, 10'000);

    std::thread writer([&] {
        for (int k = 0; k < 10; ++k) map_writer(k, k * 10);
    });

    std::vector<std::thread> readers;
    for (int r = 0; r < 4; ++r) readers.emplace_back(map_reader, r + 1);

    for (auto& th : threads) th.join();
    writer.join();
    for (auto& rd : readers) rd.join();

    std::cout << "counters[0]=" << counters[0] << '\n';
    return 0;
}