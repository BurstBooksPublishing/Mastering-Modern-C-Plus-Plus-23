#include <array>
#include <concepts>
#include <iostream>
#include <string>
#include <type_traits>
#include <utility>

// type_list: variadic template holding a sequence of types
template<typename... Ts>
struct type_list {};

// contains: true if T is in Ts...
template<typename T, typename... Ts>
struct contains : std::disjunction<std::is_same<T, Ts>...> {};

template<typename T, typename... Ts>
inline constexpr bool contains_v = contains<T, Ts...>::value;

// total_size_v: sum of sizeof(Ts)...
template<typename... Ts>
inline constexpr std::size_t total_size_v = (sizeof(Ts) + ... + 0);

// compute_offsets: compile-time prefix-sum of sizes
template<typename... Ts>
consteval std::array<std::size_t, sizeof...(Ts)> compute_offsets() {
    std::array<std::size_t, sizeof...(Ts)> offs{};
    std::size_t acc = 0;
    std::size_t idx = 0;
    ((offs[idx++] = acc, acc += sizeof(Ts)), ...);
    return offs;
}

// has_serialize: detects T::serialize() -> std::string
template<typename T, typename = void>
struct has_serialize : std::false_type {};

template<typename T>
struct has_serialize<T, std::void_t<decltype(std::declval<T>().serialize())>>
    : std::is_convertible<decltype(std::declval<T>().serialize()), std::string> {};

// Serializable concept
template<typename T>
concept Serializable = has_serialize<T>::value;

// demo types
struct A { int x; };
struct B { double y; std::string serialize() const { return "B"; } };
struct C { char z; std::string serialize() { return "C"; } };

int main() {
    using list = type_list<A, B, C>;
    constexpr auto total = total_size_v<A, B, C>;
    constexpr auto offs = compute_offsets<A, B, C>();

    std::cout << "Total size = " << total << '\n';
    std::cout << "Offsets: ";
    for (auto o : offs) std::cout << o << ' ';
    std::cout << '\n';

    static_assert(!Serializable<A>);
    static_assert(Serializable<B> && Serializable<C>);

    if constexpr (Serializable<B>) {
        B b{};
        std::cout << "B serialized: " << b.serialize() << '\n';
    }
}