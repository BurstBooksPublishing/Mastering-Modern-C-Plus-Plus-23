#include <vector>
#include <future>
#include <stdexcept>

using Matrix = std::vector<std::vector<int>>;

Matrix multiply(const Matrix& A, const Matrix& B) {
    if (A.empty() || B.empty() || A[0].empty() || B[0].empty())
        throw std::invalid_argument("Empty matrix");

    const std::size_t m = A.size();
    const std::size_t n = B[0].size();
    const std::size_t p = B.size();

    if (A[0].size() != p)
        throw std::invalid_argument("Incompatible dimensions");

    Matrix C(m, std::vector<int>(n, 0));

    // Launch one task per row to balance parallelism and overhead
    std::vector<std::future<void>> futures;
    futures.reserve(m);

    for (std::size_t i = 0; i < m; ++i) {
        futures.emplace_back(std::async(std::launch::async, [&A, &B, &C, i, n, p] {
            for (std::size_t j = 0; j < n; ++j) {
                int sum = 0;
                for (std::size_t k = 0; k < p; ++k)
                    sum += A[i][k] * B[k][j];
                C[i][j] = sum;
            }
        }));
    }

    for (auto& f : futures) f.get();
    return C;
}