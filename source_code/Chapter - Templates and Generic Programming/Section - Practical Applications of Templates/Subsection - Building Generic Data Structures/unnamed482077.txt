#include <iostream>
#include <memory>
#include <stdexcept>

template <typename T>
class LinkedList {
public:
    LinkedList() = default;
    LinkedList(const LinkedList& other) { *this = other; }
    LinkedList& operator=(const LinkedList& other) {
        if (this == &other) return *this;
        clear();
        for (auto* cur = other.head.get(); cur; cur = cur->next.get())
            push_back(cur->data);
        return *this;
    }
    LinkedList(LinkedList&&) noexcept = default;
    LinkedList& operator=(LinkedList&&) noexcept = default;
    ~LinkedList() = default;

    void push_front(const T& value) {
        head = std::make_unique<Node>(value, std::move(head));
    }

    void push_back(const T& value) {
        auto newNode = std::make_unique<Node>(value);
        if (!head) {
            head = std::move(newNode);
            return;
        }
        Node* cur = head.get();
        while (cur->next) cur = cur->next.get();
        cur->next = std::move(newNode);
    }

    void pop_front() {
        if (!head) throw std::out_of_range("pop_front on empty list");
        head = std::move(head->next);
    }

    bool empty() const { return !head; }

    void print() const {
        for (auto* cur = head.get(); cur; cur = cur->next.get())
            std::cout << cur->data << ' ';
        std::cout << '\n';
    }

    void clear() { head.reset(); }

private:
    struct Node {
        T data;
        std::unique_ptr<Node> next;
        Node(const T& val, std::unique_ptr<Node> nxt = nullptr)
            : data(val), next(std::move(nxt)) {}
    };
    std::unique_ptr<Node> head;
};

int main() {
    LinkedList<int> intList;
    intList.push_front(10);
    intList.push_front(20);
    intList.push_front(30);
    intList.print(); // 30 20 10

    LinkedList<std::string> strList;
    strList.push_back("Hello");
    strList.push_back("World");
    strList.print(); // Hello World
}