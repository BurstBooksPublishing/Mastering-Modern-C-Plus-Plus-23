#include <filesystem>
#include <fstream>
#include <iostream>
#include <map>
#include <optional>
#include <sstream>
#include <string>
#include <string_view>
#include <vector>
#include <cstdint>
#include <cstdlib>
#include <algorithm>
#include <cctype>

namespace fs = std::filesystem;

struct CLI {
    std::map<std::string, std::string> opts;
    std::vector<std::string> args;

    void parse(int argc, char** argv) {
        for (int i = 1; i < argc; ++i) {
            std::string_view tok = argv[i];
            if (tok.starts_with("--")) {
                auto eq = tok.find('=');
                if (eq != std::string_view::npos) {
                    opts[std::string(tok.substr(2, eq - 2))] = std::string(tok.substr(eq + 1));
                } else {
                    std::string key = std::string(tok.substr(2));
                    if (i + 1 < argc && argv[i + 1][0] != '-') {
                        opts[key] = argv[++i];
                    } else {
                        opts[key] = "1";
                    }
                }
            } else if (tok.starts_with('-') && tok.size() > 1) {
                for (size_t j = 1; j < tok.size(); ++j) {
                    std::string key(1, tok[j]);
                    if (j + 1 == tok.size() && i + 1 < argc && argv[i + 1][0] != '-') {
                        opts[key] = argv[++i];
                        break;
                    } else {
                        opts[key] = "1";
                    }
                }
            } else {
                args.emplace_back(tok);
            }
        }
    }
};

std::optional<fs::path> find_config(std::string_view toolname) {
    fs::path local = fs::current_path() / "tool.cfg";
    if (fs::exists(local)) return local;
    if (auto env = std::getenv("XDG_CONFIG_HOME"); env && *env) {
        fs::path p = fs::path(env) / toolname / "tool.cfg";
        if (fs::exists(p)) return p;
    }
    if (auto home = std::getenv("HOME"); home && *home) {
        fs::path p = fs::path(home) / ".config" / toolname / "tool.cfg";
        if (fs::exists(p)) return p;
    }
    return std::nullopt;
}

std::map<std::string, std::string> parse_config(const fs::path& p) {
    std::map<std::string, std::string> cfg;
    std::ifstream in(p);
    std::string line;
    while (std::getline(in, line)) {
        auto pos = line.find('=');
        if (pos == std::string::npos) continue;
        std::string key = line.substr(0, pos);
        std::string val = line.substr(pos + 1);
        auto trim = [](std::string& s) {
            s.erase(s.begin(), std::find_if(s.begin(), s.end(), [](unsigned char c) { return !std::isspace(c); }));
            s.erase(std::find_if(s.rbegin(), s.rend(), [](unsigned char c) { return !std::isspace(c); }).base(), s.end());
        };
        trim(key); trim(val);
        if (!key.empty()) cfg[key] = val;
    }
    return cfg;
}

struct Counts { std::uint64_t lines{}, words{}, bytes{}; };

Counts count_stream(std::istream& in) {
    Counts c;
    std::string line;
    while (std::getline(in, line)) {
        ++c.lines;
        c.bytes += line.size() + 1;
        std::istringstream iss(line);
        std::string token;
        while (iss >> token) ++c.words;
    }
    return c;
}

int main(int argc, char** argv) {
    CLI cli;
    cli.parse(argc, argv);
    if (auto cfg_path = find_config("mytool")) {
        auto cfg = parse_config(*cfg_path);
        if (cfg.contains("default_mode")) cli.opts.try_emplace("mode", cfg.at("default_mode"));
    }

    if (cli.args.empty()) {
        std::cerr << "usage: mytool <command> [files...]\n";
        return 2;
    }
    std::string cmd = cli.args.front();
    std::vector<std::string> files(cli.args.begin() + 1, cli.args.end());
    if (files.empty()) files.emplace_back("-");

    if (cmd == "count") {
        for (const auto& fname : files) {
            Counts c;
            if (fname == "-") {
                c = count_stream(std::cin);
            } else {
                std::ifstream in(fname, std::ios::binary);
                if (!in) {
                    std::perror(fname.c_str());
                    continue;
                }
                c = count_stream(in);
            }
            std::cout << fname << ": " << c.lines << " lines, " << c.words << " words, " << c.bytes << " bytes\n";
        }
        return 0;
    }

    std::cerr << "unknown command: " << cmd << "\n";
    return 3;
}